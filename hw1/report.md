Функции `f` и `g`, так же как и константы (eps) возьмём соответствующие главе, в силу описания оптимальности в самой главе и для возможности сравниться с учебником.

---

#### Все вычисления производятся на компьютере со следующими параметрами:

VivoBook_ASUSLaptop X712FBC_A7
64KiB BIOS
8GiB System Memory
processor: Intel(R) Core(TM) i5-10210U CP

---

В алгоритм 11.6 так же допишем распараллеливание подсчёта минимального изменения на итерации.

Сравнимся со статьёй. Составим таблицу аналогичную таблице 11.3 из книги.
В силу разных вычислительных машин и seed-а, понятно что результаты будут различаться. 

Время так же в секундах. Количество потоков 8. eps = 0,1. 

Размер сетки | k для алгоритма 11.1 | t для алгоритма 11.1 | k для алгоритма 11.6 | t для алгоритма 11.6
---|---|---|---|---
100 | 210 | 0.098 | 210 | 0.007
200 | 277 | 0.438 | 277 | 0.072
300 | 305 | 1.043 | 305 | 0.284
400 | 321 | 2.021 | 321 | 1.308
500 | 330 | 3.106 | 330 | 1.858
600 | 337 | 4.522 | 337 | 3.322
700 | 342 | 6.283 | 342 | 4.567
800 | 345 | 8.863 | 345 | 6.903
900 | 348 | 11.172 | 348 | 7.687
1000 | 350 | 13.645 | 350 | 10.356
2000 | 361 | 56.879 | 361 | 39.743
3000 | 365 | 127.490 | 365 | 96.791

Что можно заметить: для сетки размера 100, в книге быстрее работает не распараллеленый алгоритм, а у меня получилось наоборот. Отношение времени работы варьируется от 1.5 до 8, что в целом близко к книжному (от 0.2 до 4.5).

Так же, интересно, что происходит при различном числе потоков. Фиксируем те же переменные, что и до этого, кроме числа потоков. Размер сетки возьмём за 3000.


1 | 365 | 67.710
2 | 365 | 35.798
3 | 365 | 27.913
4 | 365 | 25.615
8 | 365 | 24.742
16 | 365 | 27.769
32 | 365 | 29.502

